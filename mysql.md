# MySQL学习笔记

## 前言

### MySQL环境说明

没有特别指定，存储引擎默认为InnoDB存储引擎。

-----

## 日志文件

日志文件分为：

- bin log：二进制日志

  **说明：**
  
    1. 记录**更改**的操作日志，不包括`SELECT`、`SHOW`之类操作。但是操作本身没有导致更改（0 rows affected），也可能会记录到binlog中。
    
    2. 默认情况，未开启，需要手动开启。
  
  **作用：**
  
    1. 恢复Recovery：数据的恢复；
    
    2. 赋值Replication：数据的复制到其他节点，进行实时同步
    
    3. 审计Audit：查询日志，判断是否产生注入攻击
  
- redo log：重做日志


## 锁

Innodb的锁可以是基于MVCC实现的，可以是行级锁。
MyISAM的锁是表级锁。



### 锁的类型和实现

**一致性非锁定读**

InnoDB存储引擎，通过MVCC的方式读取当前执行时间数据库中的行的数据。

MVCC（多版本并发控制）：一个记录可能有不止一个快照数据，一般称为行多版本技术。由此带来的并发控制，称为MVCC。

**一致性锁定读**

默认配置下，事务的隔离级别为`REPEATABLE READ`，InnoDB的SELECT操作使用一致性非锁定读。

但是，在某些情况下，用户需要显示的对数据库读取操作进行加锁以保证数据逻辑的一致性。

InnoDB对SELECT操作支持两种一致性的锁定读（locking read）操作：

1. SELECT ... FOR UPDATE

   对读取的行记录加一个X锁

2. SELECT ... LOCK IN SHARE MODE

   对读取的行记录加一个S锁




### 锁问题

锁提高了并发，但是会带来潜在的问题。

**数据库默认的隔离级别**

- InnoDB默认的隔离级别为：`READ REPEATABLE`
- Microsoft SQL Server / Oracle：`READ COMMITTED`


**脏读**

与“脏页”的概念不同。

1. “脏页”表示在缓存池中已经修改的页，但是还没有刷新到磁盘中，即缓存中的页和磁盘中的页的数据是不一致的。“脏页”是因为数据库实例的内存和磁盘的异步造成的。读取“脏页”并不会影响数据一致性，因为最终都会被刷新到磁盘中，达成最终一致性。

2. “脏数据”是事务对缓冲池中的行记录的修改，并没有被提交（commit）。“脏数据”是指未提交的数据，如果读到了另一个事务中未提交的数据，则违反了数据库的隔离性。

“脏读”现象在生产环境中并不常发生。其出现的条件需要将事务的隔离级别修改为：`READ UNCOMMITTED`。



![](./assets/mysql_dirty_read.png)



**不可重复读**

不可重复读指的是：一个事务A内多次读取同一个数据集合。在这个事务A还没有结束时，另外一个事务B也访问了同一数据集合，并做了一些DML操作。事务A在在一个事务内读到的数据是不一样的情况。


与“脏读”的区别：

- 脏读读到的是未提交的数据
- 不可重复读读到的是已经提交的数据。（在上面的情况下，是破坏了事务A的数据库一致性的要求）


![](./assets/mysql_read_unrepeatable.png)


InnoDB存储引擎中，通过使用`Next-Key Lock算法`来避免不可重复读的问题。



**丢失更新**

一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。

例如：

1. 事务T1将行记录r更新为v1，但是事务T1并未提交。
2. 与此同时，事务T2将行记录r更新为v2，事务T2未提交。
3. 事务T1提交。
4. 事务T2提交。

上述例子中，事务T2并不能对行记录r进行更新操作，会被阻塞，直到事务T1提交。



要避免丢失更新发生，需要让事务在这种情况下的操作变成串行化，而不是并行操作。增加排他X锁。

